\chapter{Технологическая часть}

В данном разделе производится выбор средств реализации, а также приводятся требования к программному обеспечению (ПО), листинги реализованных алгоритмов.

\section{Требования к ПО}

На вход программе подается массив элементов целого или вещественного, на выходе должен быть получен отсортированный массив. 
Результирующий массив вычислен с помощью однопоточного алгоритма блочной сортировки и алгоритма, использующего параллелизм. 
Также необходимо вывести затраченное каждым алгоритмом процессорное время с учетом количества потоков второй реализации.

\section{Выбор средств реализации}

В качестве языка программирования для реализации данной лабораторной работы был выбран язык Swift \cite{swift}. 
Данный язык создан компаний Apple для разработки программного обеспечения для macOS, iOS, watchOS и tvOS. 
Выбор обоснован желанием расширить знания в области применения данного языка, а также возможностью создать на основе написанного кода приложение.

Кроме того, в Swift есть фреймворк CoreFoundation \cite{core}, который предоставляет функции для замера процессорного времени. 
В качестве среды разработки выбран XCode \cite{xcode}. 

Для работы с потоками будет использоваться класс NSThread \cite{thread} библиотеки Foundation. 

\section{Листинги кода}

В листингах \ref{lst:code1} и \ref{lst:code3} представлены реализации рассматриваемых алгоритмов блочной сортировки: однопоточная и многопоточная. 

\hspace{0.6cm}В Листинге \ref{lst:code1} показана реализация однопоточного алгоритма блочной сортировки.
\begin{lstlisting}[label=lst:code1, caption=Функция алгоритма блочной сортировки однопоточная]
func bucketSort(_ array: [Double]) -> [Double]  {
    var resultArray: [Double] = []
    let maxValue = array.max()!
    let minValue = array.min()!
    let lenArray = array.count
    let offset = array.filter { $0 < 0 }.count
    var sizeValue = maxValue / Double(lenArray) as Double
    if minValue < 0 { sizeValue = maxValue + (-minValue) / Double(lenArray) as Double }
    var buckets: [[Double]] = []
    for _ in 0..<lenArray { buckets.append([]) }
    for i in 0..<lenArray {
        let j = Int(array[i] / sizeValue)
        if j != lenArray { buckets[j + offset].append(array[i]) } 
        else { buckets[lenArray - 1].append(array[i]) }
    }
    for i in 0..<lenArray {
        insertionSort(bucket: &buckets[i])
        resultArray.append(contentsOf: buckets[i])
    }
    return resultArray
}
\end{lstlisting}


\hspace{0.6cm}В Листинге \ref{lst:code2} показана реализация алгоритма сортировки вставками.
\begin{lstlisting}[label=lst:code2, caption=Функция алгоритма сортировки вставками]
func insertionSort(bucket: inout [Double]) {
    for i in 0..<bucket.count {
        let tmp = bucket[i]
        var j = i - 1
        while (j >= 0 && tmp < bucket[j]) {
            bucket[j + 1] = bucket[j]
            j = j - 1
        }
        bucket[j + 1] = tmp }
}
\end{lstlisting}

\hspace{0.6cm}В Листинге \ref{lst:code3} показана реализация многопоточного алгоритма блочной сортировки.
\begin{lstlisting}[label=lst:code3, caption=Функция алгоритма блочной сортировки многопоточная]
func bucketSort(_ array: [Double]) -> [Double]  {
    var resultArray: [Double] = []
    let maxValue = array.max()!
    let minValue = array.min()!
    let lenArray = array.count
    let offset = array.filter { $0 < 0 }.count
    var sizeValue = maxValue / Double(lenArray) as Double
    if minValue < 0 { sizeValue = maxValue + (-minValue) / Double(lenArray) as Double }
    var buckets: [[Double]] = []
    for _ in 0..<lenArray { buckets.append([]) }
    for i in 0..<lenArray {
        let j = Int(array[i] / sizeValue)
        if j != lenArray {
            buckets[j + offset].append(array[i])
        } else { buckets[lenArray - 1].append(array[i]) }
    }
    var threads = [Thread]()
    for _ in 0..<threadCount { threads.append(Thread()) }
    
    for i in 0..<lenArray {
        let thread = Thread {
            insertionSort(bucket: &buckets[i])
            resultArray.append(contentsOf: buckets[i])
        }
        let j = i % threadCount
        threads[j] = thread
        threads[j].start()
    }    
    return resultArray
}
\end{lstlisting}

В листинге \ref{lst:code2} представлена реализации алгоритма сортировки вставками, применяемая в каждому выделенному блоку на последнем этапе блочной сортировки.  

\section{Функциональные тесты}

В таблице~\ref{tbl:test} приведены тесты для функций, реализующих алгоритмы сортировки. 
Все тесты пройдены успешно.

\begin{table}[h!]
	\begin{center}
		\begin{tabular}{|c|c|c|}
			\hline
			Входной массив & Результат & Ожидаемый результат \\ 
			\hline
			$[15, 25, 35, 45]$ & $[15, 25, 35, 45]$  & $[15, 25, 35, 45]$\\\hline
			$[55, 45, 35, 25]$  & $[25, 35, 45, 55]$ & $[25, 35, 45, 55]$\\\hline
			$[-10, -20, -30, -25]$  & $[-30, -25, -20, -10]$  & $[-30, -25, -20, -10]$\\\hline
			$[40, -10, -30, 75]$  & $[-30, -10, 40, 75]$  & $[-30, -10, 40, 75]$\\\hline
			$[100]$  & $[100]$  & $[100]$\\\hline
			$[-20]$  & $[-20]$  & $[-20]$\\\hline
			$[1.1, 2.2, 3.3, 4.4]$  & $[1.1, 2.2, 3.3, 4.4]$  & $[1.1, 2.2, 3.3, 4.4]$\\\hline
			$[1.1, -2.2, 3.3, -4.4]$  & $[-4.4, -2.2, 1.1, 3.3]$  &  $[-4.4, -2.2, 1.1, 3.3]$\\\hline
			$[-1.1, -2.2, -3.3, -4.4]$  & $[-4.4, 3.3, -2.2, -1.1]$  &  $[-4.4, -3.3, -2.2, -1.1]$\\\hline
			$[10, 10]$  & $[10, 10]$  & $[10, 10]$ \\\hline
		\end{tabular}
		\caption{\label{tbl:test}Тестирование функций}
	\end{center}
\end{table}

\section{Вывод}

В данном разделе были разработаны исходные коды алгоритмов: однопоточная и многопоточная реализации алгоритма блочной сортировки, а также вспомогательный алгоритм -- сортировка вставками. 
